{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and SDK Integration",
        "description": "Initialize the project with TypeScript, install required dependencies including MCP Server SDK and Claude Code SDK, and set up the basic project structure.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. Create a new TypeScript project with `npm init -y`\n2. Install TypeScript: `npm install typescript --save-dev`\n3. Initialize TypeScript config: `npx tsc --init`\n4. Configure tsconfig.json for ES Modules\n5. Install required SDKs: `npm install @modelcontextprotocol/sdk @anthropic-ai/claude-code`\n6. Set up project directory structure including src folder and .postgen directory handling\n7. Create basic entry point (index.ts)\n8. Add Docker configuration (Dockerfile and docker-compose.yml)\n9. Set up ESLint and Prettier for code style enforcement\n10. Configure package.json scripts for building, testing, and running",
        "testStrategy": "Verify project structure is correct, dependencies are installed, and TypeScript compilation works without errors. Test basic imports from both SDKs to ensure they're properly integrated. Validate the dependency injection container, error handling, and server lifecycle management.",
        "subtasks": [
          {
            "id": 1,
            "title": "Node.js project initialization",
            "description": "Initialize Node.js project with package.json and ES Module configuration",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "TypeScript setup",
            "description": "Install TypeScript and configure tsconfig.json for ES2022/Node16",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "MCP Server SDK integration",
            "description": "Install and integrate the MCP Server SDK (@modelcontextprotocol/sdk)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Core dependencies installation",
            "description": "Install core dependencies: winston (logging), dotenv (env vars)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Project structure setup",
            "description": "Create organized src/ directory structure with dependency injection architecture",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Dependency injection implementation",
            "description": "Implement basic dependency injection container (src/core/container/DIContainer.ts)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Error handling setup",
            "description": "Establish core error hierarchy (src/core/errors/BaseError.ts)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Configuration management",
            "description": "Set up configuration management (src/config/index.ts)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Entry point creation",
            "description": "Create basic entry point (src/index.ts) with server lifecycle management",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Logger implementation",
            "description": "Implement logger utility (src/utils/logger.ts)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "MCP server implementation",
            "description": "Implement core MCP server class (src/core/MarketingPostGeneratorServer.ts)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "Development tooling setup",
            "description": "Set up ESLint and Prettier for code style enforcement",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 13,
            "title": "Docker configuration",
            "description": "Create Dockerfile and docker-compose.yml for containerization",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 14,
            "title": "Claude Code SDK integration",
            "description": "Install and integrate the Claude Code SDK (@anthropic-ai/claude-code)",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 15,
            "title": "Final validation and testing",
            "description": "Verify all components work together correctly and test the basic functionality",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "MCP Server Implementation",
        "description": "Create the core MCP server implementation that supports both local and remote (HTTP) modes according to the MCP specification.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "1. Import the MCP Server SDK\n2. Create a server class that initializes the MCP server\n3. Implement configuration options for both local and remote modes\n4. Set up HTTP server for remote mode using Express or similar\n5. Implement proper error handling and logging\n6. Create server startup and shutdown methods\n7. Add health check endpoint for remote mode\n8. Implement server configuration from environment variables\n9. Add connection validation logic\n\nExample server initialization:\n```typescript\nimport { MCPServer } from '@modelcontextprotocol/sdk';\n\nexport class MarketingPostGeneratorServer {\n  private mcpServer: MCPServer;\n  \n  constructor(config: ServerConfig) {\n    this.mcpServer = new MCPServer({\n      mode: config.mode, // 'local' or 'remote'\n      port: config.port,\n      // other configuration options\n    });\n  }\n  \n  async start() {\n    await this.mcpServer.start();\n    console.log(`MCP Server started in ${this.mcpServer.mode} mode`);\n  }\n  \n  async stop() {\n    await this.mcpServer.stop();\n  }\n}\n```\n\n**Implementation Details:**\n- Integrated MCP SDK's StreamableHTTPServerTransport for remote mode\n- Set up Express.js server with middleware (helmet, cors, body parsing)\n- Implemented /health endpoint returning server status and metadata\n- Extended ServerConfig interface with HTTP-specific options including DNS rebinding protection\n- Added security features including DNS rebinding protection, CORS configuration, and security headers\n- Implemented session management with UUID generation and logging\n- Created proper error handling and request validation for both transport modes",
        "testStrategy": "Test server initialization in both local and remote modes. Verify server starts and stops correctly. For remote mode, test HTTP endpoints respond appropriately. Use mock clients to verify connection handling.\n\n**Test Results:**\n- ✅ Local mode (stdio): Server starts successfully and accepts connections\n- ✅ Remote mode (HTTP): Server starts on port 3000 with health check at /health\n- ✅ Health endpoint: Returns proper JSON response with server metadata  \n- ✅ MCP Protocol: Successfully handles MCP initialize requests via HTTP\n- ✅ Session Management: Creates and logs new MCP sessions with UUIDs\n- ✅ Configuration: Both default and remote configurations work correctly\n- ✅ TypeScript Build: All code compiles without errors",
        "subtasks": [
          {
            "id": 1,
            "title": "HTTP Transport Integration",
            "description": "Integrate the MCP SDK's StreamableHTTPServerTransport for remote mode operation",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Express Server Setup",
            "description": "Create Express.js server with proper middleware (helmet, cors, body parsing)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Health Check Endpoint",
            "description": "Implement /health endpoint returning server status and metadata",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Configuration Enhancement",
            "description": "Extend ServerConfig interface with HTTP-specific options including DNS rebinding protection",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Dual Transport Support",
            "description": "Ensure server supports both local (stdio) and remote (HTTP) modes based on configuration",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Security Features",
            "description": "Add DNS rebinding protection, CORS configuration, and security headers",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Connection Validation",
            "description": "Implement proper error handling and request validation for both transport modes",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Session Management",
            "description": "Integrate MCP session initialization with UUID generation and logging",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Claude Code Integration",
        "description": "Integrate the Claude Code library to enable agentic operations within the MCP server.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "1. Import the Claude Code SDK\n2. Create a service class to manage Claude Code interactions\n3. Implement initialization with proper API key handling\n4. Create methods for common Claude operations (text generation, etc.)\n5. Set up proper error handling for API calls\n6. Implement retry logic for failed requests\n7. Add rate limiting to prevent API abuse\n8. Create utility functions for prompt construction\n\n```typescript\nimport { Claude } from '@anthropic-ai/claude-code';\n\nexport class ClaudeService {\n  private claude: Claude;\n  \n  constructor(apiKey: string) {\n    this.claude = new Claude({\n      apiKey,\n    });\n  }\n  \n  async generateContent(prompt: string, options?: any) {\n    try {\n      const response = await this.claude.complete({\n        prompt,\n        // other options\n      });\n      return response.completion;\n    } catch (error) {\n      // Handle error\n      console.error('Claude API error:', error);\n      throw new Error(`Failed to generate content: ${error.message}`);\n    }\n  }\n}\n```",
        "testStrategy": "Create unit tests with mocked API responses to verify Claude Code integration works correctly. Test error handling and retry logic. Create integration tests that make actual API calls (with proper API key handling for CI/CD).",
        "subtasks": [
          {
            "id": 1,
            "title": "Create feature branch",
            "description": "Create and push feature branch 'feature/claude-integration' for Claude Code integration work",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Install dependencies",
            "description": "Install Claude Code SDK and any other required dependencies",
            "status": "done",
            "dependencies": [],
            "details": "<info added on 2025-07-04T13:42:40.962Z>\nSuccessfully installed @anthropic-ai/sdk version 0.56.0. Package added to dependencies in package.json. Verified installation with npm list. SDK is now ready for integration with the Claude API in subsequent development tasks.\n</info added on 2025-07-04T13:42:40.962Z>",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Configuration updates",
            "description": "Update configuration files to support Claude API keys and other required settings",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Claude service implementation",
            "description": "Implement the ClaudeService class with methods for text generation and other operations",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Dependency Injection integration",
            "description": "Register the Claude service in the application's DI container",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Testing",
            "description": "Create unit and integration tests for the Claude service implementation",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Init Prompt Implementation",
        "description": "Create the initialization prompt that sets up the .postgen directory structure when given a domain/URL of the main blog page.",
        "details": "1. Create a prompt handler for the init command\n2. Implement logic to validate the provided domain/URL\n3. Create the .postgen directory if it doesn't exist\n4. Set up subdirectories for different data types (samples, summaries, content plans, etc.)\n5. Create initial configuration file with the domain information\n6. Add validation to ensure the directory was created successfully\n7. Implement proper error handling for file system operations\n\n```typescript\nimport { MCPPrompt } from '@modelcontextprotocol/sdk';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport const initPrompt: MCPPrompt = {\n  name: 'marketing_post_generator_mcp__init',\n  description: 'Initialize the Marketing Post Generator with a blog domain',\n  parameters: {\n    domain: {\n      type: 'string',\n      description: 'The domain/URL of the main blog page',\n    },\n  },\n  handler: async ({ domain }) => {\n    try {\n      // Validate domain\n      const url = new URL(domain);\n      \n      // Create .postgen directory structure\n      const postgenDir = path.join(process.cwd(), '.postgen');\n      await fs.mkdir(postgenDir, { recursive: true });\n      \n      // Create subdirectories\n      const dirs = ['samples', 'summaries', 'content-plans', 'posts'];\n      for (const dir of dirs) {\n        await fs.mkdir(path.join(postgenDir, dir), { recursive: true });\n      }\n      \n      // Create config file\n      const config = {\n        domain: url.hostname,\n        initialized: new Date().toISOString(),\n      };\n      await fs.writeFile(\n        path.join(postgenDir, 'config.json'),\n        JSON.stringify(config, null, 2)\n      );\n      \n      return `Successfully initialized .postgen directory for ${url.hostname}`;\n    } catch (error) {\n      throw new Error(`Failed to initialize: ${error.message}`);\n    }\n  },\n};\n```",
        "testStrategy": "Test the init prompt with various valid and invalid domain inputs. Verify the .postgen directory structure is created correctly. Test error handling for invalid domains and file system errors.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Sample Tool Implementation",
        "description": "Implement the 'sample' tool that fetches and analyzes blog posts from a domain to extract positioning, tone of voice, and content strategy.",
        "details": "1. Create a tool definition for the sample functionality\n2. Implement web scraping logic to fetch blog posts from a domain\n3. Use Claude Code to analyze the content for positioning, tone, and strategy\n4. Store the results in the .postgen/samples directory\n5. Implement pagination and sampling logic to get a representative set of posts\n6. Add rate limiting to prevent overloading the target site\n7. Implement caching to avoid re-fetching already analyzed content\n\n```typescript\nimport { MCPTool } from '@modelcontextprotocol/sdk';\nimport { ClaudeService } from './services/claude-service';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport const sampleTool: MCPTool = {\n  name: 'marketing_post_generator_mcp__sample',\n  description: 'Sample blog posts from a domain to extract positioning, tone, and content strategy',\n  parameters: {\n    domain: {\n      type: 'string',\n      description: 'The domain to sample from',\n    },\n    sampleSize: {\n      type: 'number',\n      description: 'Number of posts to sample',\n      default: 5,\n    },\n  },\n  handler: async ({ domain, sampleSize }, { claudeService }) => {\n    // Validate .postgen directory exists\n    const postgenDir = path.join(process.cwd(), '.postgen');\n    try {\n      await fs.access(postgenDir);\n    } catch (error) {\n      throw new Error('Please run the init prompt first');\n    }\n    \n    // Fetch blog posts\n    const posts = await fetchBlogPosts(domain, sampleSize);\n    \n    // Analyze posts with Claude\n    const analysis = await claudeService.generateContent(\n      `Analyze these ${posts.length} blog posts from ${domain} and extract:\n1. Overall positioning\n2. Tone of voice\n3. Content strategy\n\nPosts:\n${posts.map((p, i) => `Post ${i+1}: ${p.title}\\n${p.content}\\n---`).join('\\n')}`\n    );\n    \n    // Save results\n    const samplePath = path.join(postgenDir, 'samples', `${domain}-${Date.now()}.json`);\n    await fs.writeFile(\n      samplePath,\n      JSON.stringify({\n        domain,\n        sampleSize,\n        posts: posts.map(p => ({ title: p.title, url: p.url })),\n        analysis,\n        timestamp: new Date().toISOString(),\n      }, null, 2)\n    );\n    \n    return {\n      message: `Successfully sampled ${posts.length} posts from ${domain}`,\n      analysis,\n    };\n  },\n};\n\nasync function fetchBlogPosts(domain, count) {\n  // Implementation of web scraping logic\n  // This would use a library like cheerio or puppeteer\n}\n```",
        "testStrategy": "Test with mock web responses to verify scraping logic. Test analysis with mock Claude responses. Verify results are correctly stored in the .postgen directory. Test rate limiting and error handling for network issues.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Summarize Tool Implementation",
        "description": "Implement the 'summarize' tool that takes a blog post URL and generates a concise summary of its content.",
        "details": "1. Create a tool definition for the summarize functionality\n2. Implement web scraping to fetch the content of a specific blog post\n3. Use Claude Code to generate a summary of the post\n4. Store the summary in the .postgen/summaries directory\n5. Implement caching to avoid re-summarizing already processed posts\n6. Add proper error handling for invalid URLs or inaccessible content\n\n```typescript\nimport { MCPTool } from '@modelcontextprotocol/sdk';\nimport { ClaudeService } from './services/claude-service';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\n\nexport const summarizeTool: MCPTool = {\n  name: 'marketing_post_generator_mcp__summarize',\n  description: 'Summarize a blog post from its URL',\n  parameters: {\n    url: {\n      type: 'string',\n      description: 'The URL of the blog post to summarize',\n    },\n  },\n  handler: async ({ url }, { claudeService }) => {\n    // Validate .postgen directory exists\n    const postgenDir = path.join(process.cwd(), '.postgen');\n    try {\n      await fs.access(postgenDir);\n    } catch (error) {\n      throw new Error('Please run the init prompt first');\n    }\n    \n    // Create a hash of the URL for the filename\n    const urlHash = crypto.createHash('md5').update(url).digest('hex');\n    const summaryPath = path.join(postgenDir, 'summaries', `${urlHash}.json`);\n    \n    // Check if we already have a summary\n    try {\n      const existingSummary = await fs.readFile(summaryPath, 'utf-8');\n      return JSON.parse(existingSummary);\n    } catch (error) {\n      // No existing summary, continue\n    }\n    \n    // Fetch the blog post content\n    const { title, content } = await fetchBlogPost(url);\n    \n    // Generate summary with Claude\n    const summary = await claudeService.generateContent(\n      `Summarize this blog post in a concise way that captures the main points and key insights:\\n\\nTitle: ${title}\\n\\nContent: ${content}`\n    );\n    \n    // Save the summary\n    const result = {\n      url,\n      title,\n      summary,\n      timestamp: new Date().toISOString(),\n    };\n    \n    await fs.writeFile(summaryPath, JSON.stringify(result, null, 2));\n    \n    return result;\n  },\n};\n\nasync function fetchBlogPost(url) {\n  // Implementation of web scraping for a specific post\n  // This would use a library like cheerio or puppeteer\n}\n```",
        "testStrategy": "Test with mock web responses to verify post fetching. Test summary generation with mock Claude responses. Verify summaries are correctly stored in the .postgen directory. Test caching behavior and error handling for network issues.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Generate Tone Tool Implementation",
        "description": "Implement the 'generate_tone' tool that analyzes content to determine the tone of voice used in a blog or specific post.",
        "details": "1. Create a tool definition for the tone generation functionality\n2. Implement logic to analyze either a specific post or use samples from a domain\n3. Use Claude Code to extract tone characteristics\n4. Store the tone analysis in the .postgen directory\n5. Implement options for different levels of detail in the analysis\n\n```typescript\nimport { MCPTool } from '@modelcontextprotocol/sdk';\nimport { ClaudeService } from './services/claude-service';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport const generateToneTool: MCPTool = {\n  name: 'marketing_post_generator_mcp__generate_tone',\n  description: 'Analyze content to determine the tone of voice used',\n  parameters: {\n    source: {\n      type: 'string',\n      description: 'URL of a specific post or domain name',\n    },\n    detailLevel: {\n      type: 'string',\n      description: 'Level of detail in the analysis',\n      enum: ['basic', 'detailed', 'comprehensive'],\n      default: 'detailed',\n    },\n  },\n  handler: async ({ source, detailLevel }, { claudeService }) => {\n    // Validate .postgen directory exists\n    const postgenDir = path.join(process.cwd(), '.postgen');\n    try {\n      await fs.access(postgenDir);\n    } catch (error) {\n      throw new Error('Please run the init prompt first');\n    }\n    \n    let content;\n    let sourceType;\n    \n    // Determine if source is a URL or domain\n    try {\n      const url = new URL(source);\n      if (url.pathname === '/' || url.pathname === '') {\n        sourceType = 'domain';\n        // Get samples from the domain\n        content = await getSamplesFromDomain(url.hostname);\n      } else {\n        sourceType = 'post';\n        // Fetch specific post\n        const post = await fetchBlogPost(source);\n        content = post.content;\n      }\n    } catch (error) {\n      // Not a valid URL, assume it's a domain\n      sourceType = 'domain';\n      content = await getSamplesFromDomain(source);\n    }\n    \n    // Generate tone analysis with Claude\n    const promptByDetailLevel = {\n      basic: `Analyze this content and describe the basic tone of voice used:\\n\\n${content}`,\n      detailed: `Analyze this content and provide a detailed description of the tone of voice, including formality, emotion, and style:\\n\\n${content}`,\n      comprehensive: `Provide a comprehensive analysis of the tone of voice in this content, including formality, emotion, style, word choice patterns, sentence structure tendencies, and unique voice characteristics:\\n\\n${content}`,\n    };\n    \n    const toneAnalysis = await claudeService.generateContent(promptByDetailLevel[detailLevel]);\n    \n    // Save the analysis\n    const result = {\n      source,\n      sourceType,\n      detailLevel,\n      toneAnalysis,\n      timestamp: new Date().toISOString(),\n    };\n    \n    const tonePath = path.join(postgenDir, 'tone-analysis', `${sourceType}-${Date.now()}.json`);\n    await fs.mkdir(path.dirname(tonePath), { recursive: true });\n    await fs.writeFile(tonePath, JSON.stringify(result, null, 2));\n    \n    return result;\n  },\n};\n\nasync function getSamplesFromDomain(domain) {\n  // Implementation to get or fetch samples from a domain\n}\n\nasync function fetchBlogPost(url) {\n  // Implementation to fetch a specific blog post\n}\n```",
        "testStrategy": "Test with different source types (URL vs domain). Test different detail levels. Verify tone analysis results with mock Claude responses. Test error handling for invalid sources and network issues.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Content Plan Generator Tool Implementation",
        "description": "Implement the tool for creating and managing a content plan for future posts, taking into account domain-specific topics, content variety, and emerging trends.",
        "details": "1. Create a tool definition for content plan generation\n2. Implement logic to analyze existing content and identify gaps\n3. Use Claude Code to generate content plan suggestions\n4. Store the content plan in the .postgen/content-plans directory\n5. Implement options for different timeframes and content volumes\n6. Add functionality to update existing plans\n\n```typescript\nimport { MCPTool } from '@modelcontextprotocol/sdk';\nimport { ClaudeService } from './services/claude-service';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport const contentPlanTool: MCPTool = {\n  name: 'marketing_post_generator_mcp__content_plan',\n  description: 'Create or update a content plan for future blog posts',\n  parameters: {\n    domain: {\n      type: 'string',\n      description: 'The domain to create a content plan for',\n    },\n    timeframe: {\n      type: 'string',\n      description: 'Timeframe for the content plan',\n      enum: ['week', 'month', 'quarter'],\n      default: 'month',\n    },\n    postCount: {\n      type: 'number',\n      description: 'Number of posts to plan',\n      default: 4,\n    },\n    updateExisting: {\n      type: 'boolean',\n      description: 'Whether to update an existing plan or create a new one',\n      default: false,\n    },\n  },\n  handler: async ({ domain, timeframe, postCount, updateExisting }, { claudeService }) => {\n    // Validate .postgen directory exists\n    const postgenDir = path.join(process.cwd(), '.postgen');\n    try {\n      await fs.access(postgenDir);\n    } catch (error) {\n      throw new Error('Please run the init prompt first');\n    }\n    \n    // Get existing samples and tone analysis\n    const samples = await getExistingSamples(domain, postgenDir);\n    const toneAnalysis = await getExistingToneAnalysis(domain, postgenDir);\n    \n    // Check for existing content plan if updating\n    let existingPlan = null;\n    if (updateExisting) {\n      try {\n        existingPlan = await getLatestContentPlan(domain, postgenDir);\n      } catch (error) {\n        // No existing plan, will create a new one\n      }\n    }\n    \n    // Generate content plan with Claude\n    const prompt = buildContentPlanPrompt({\n      domain,\n      timeframe,\n      postCount,\n      samples,\n      toneAnalysis,\n      existingPlan,\n    });\n    \n    const contentPlan = await claudeService.generateContent(prompt);\n    \n    // Parse the content plan into a structured format\n    const structuredPlan = parseContentPlan(contentPlan);\n    \n    // Save the content plan\n    const planId = Date.now();\n    const planPath = path.join(postgenDir, 'content-plans', `${domain}-${planId}.json`);\n    await fs.mkdir(path.dirname(planPath), { recursive: true });\n    \n    const result = {\n      domain,\n      timeframe,\n      postCount,\n      plan: structuredPlan,\n      rawPlan: contentPlan,\n      createdAt: new Date().toISOString(),\n      updatedFrom: existingPlan ? existingPlan.createdAt : null,\n    };\n    \n    await fs.writeFile(planPath, JSON.stringify(result, null, 2));\n    \n    return result;\n  },\n};\n\nfunction buildContentPlanPrompt(options) {\n  // Build a prompt for content plan generation based on options\n}\n\nfunction parseContentPlan(rawPlan) {\n  // Parse the raw content plan into a structured format\n}\n\nasync function getExistingSamples(domain, postgenDir) {\n  // Get existing samples for the domain\n}\n\nasync function getExistingToneAnalysis(domain, postgenDir) {\n  // Get existing tone analysis for the domain\n}\n\nasync function getLatestContentPlan(domain, postgenDir) {\n  // Get the latest content plan for the domain\n}\n```",
        "testStrategy": "Test content plan generation with different parameters. Test updating existing plans. Verify plans are correctly stored in the .postgen directory. Test error handling for missing samples or tone analysis.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          5,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Post Narrative Generator Tool Implementation",
        "description": "Implement the tool for generating narratives and bullet points for upcoming posts based on the content plan.",
        "details": "1. Create a tool definition for narrative generation\n2. Implement logic to read from the content plan\n3. Use Claude Code to generate detailed narratives and bullet points\n4. Store the narratives in the .postgen/narratives directory\n5. Implement options for different narrative styles and levels of detail\n\n```typescript\nimport { MCPTool } from '@modelcontextprotocol/sdk';\nimport { ClaudeService } from './services/claude-service';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport const narrativeGeneratorTool: MCPTool = {\n  name: 'marketing_post_generator_mcp__generate_narrative',\n  description: 'Generate narratives and bullet points for upcoming posts',\n  parameters: {\n    postId: {\n      type: 'string',\n      description: 'ID of the post from the content plan',\n    },\n    style: {\n      type: 'string',\n      description: 'Style of the narrative',\n      enum: ['concise', 'detailed', 'storytelling'],\n      default: 'detailed',\n    },\n  },\n  handler: async ({ postId, style }, { claudeService }) => {\n    // Validate .postgen directory exists\n    const postgenDir = path.join(process.cwd(), '.postgen');\n    try {\n      await fs.access(postgenDir);\n    } catch (error) {\n      throw new Error('Please run the init prompt first');\n    }\n    \n    // Get the latest content plan\n    const contentPlan = await getLatestContentPlan(postgenDir);\n    if (!contentPlan) {\n      throw new Error('No content plan found. Please create a content plan first.');\n    }\n    \n    // Find the post in the content plan\n    const post = contentPlan.plan.find(p => p.id === postId);\n    if (!post) {\n      throw new Error(`Post with ID ${postId} not found in the content plan.`);\n    }\n    \n    // Get tone analysis for the domain\n    const toneAnalysis = await getExistingToneAnalysis(contentPlan.domain, postgenDir);\n    \n    // Generate narrative with Claude\n    const prompt = buildNarrativePrompt({\n      post,\n      style,\n      toneAnalysis,\n      domain: contentPlan.domain,\n    });\n    \n    const narrative = await claudeService.generateContent(prompt);\n    \n    // Parse the narrative into a structured format\n    const structuredNarrative = parseNarrative(narrative);\n    \n    // Save the narrative\n    const narrativePath = path.join(postgenDir, 'narratives', `${postId}-${Date.now()}.json`);\n    await fs.mkdir(path.dirname(narrativePath), { recursive: true });\n    \n    const result = {\n      postId,\n      title: post.title,\n      style,\n      narrative: structuredNarrative,\n      rawNarrative: narrative,\n      createdAt: new Date().toISOString(),\n    };\n    \n    await fs.writeFile(narrativePath, JSON.stringify(result, null, 2));\n    \n    return result;\n  },\n};\n\nfunction buildNarrativePrompt(options) {\n  // Build a prompt for narrative generation based on options\n  const stylePrompts = {\n    concise: 'Create a concise outline with key bullet points',\n    detailed: 'Create a detailed narrative with main sections and supporting points',\n    storytelling: 'Create a narrative that tells a compelling story around the topic',\n  };\n  \n  return `Based on the following post idea from the content plan for ${options.domain}:\\n\\nTitle: ${options.post.title}\\nTopic: ${options.post.topic}\\nKeywords: ${options.post.keywords.join(', ')}\\n\\n${stylePrompts[options.style]}\\n\\nUse this tone of voice: ${options.toneAnalysis}`;\n}\n\nfunction parseNarrative(rawNarrative) {\n  // Parse the raw narrative into a structured format\n  // This could extract sections, bullet points, etc.\n}\n\nasync function getLatestContentPlan(postgenDir) {\n  // Get the latest content plan\n}\n\nasync function getExistingToneAnalysis(domain, postgenDir) {\n  // Get existing tone analysis for the domain\n}\n```",
        "testStrategy": "Test narrative generation with different styles. Test with different post types from the content plan. Verify narratives are correctly stored in the .postgen directory. Test error handling for missing content plans or invalid post IDs.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Blog Post Generator Tool Implementation",
        "description": "Implement the tool for writing complete blog posts from scratch or based on narratives.",
        "details": "1. Create a tool definition for blog post generation\n2. Implement logic to use narratives or generate from scratch\n3. Use Claude Code to write complete blog posts\n4. Store the posts in the .postgen/posts directory\n5. Implement options for different post lengths and styles\n6. Add functionality to revise existing posts\n\n```typescript\nimport { MCPTool } from '@modelcontextprotocol/sdk';\nimport { ClaudeService } from './services/claude-service';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport const blogPostGeneratorTool: MCPTool = {\n  name: 'marketing_post_generator_mcp__write_post',\n  description: 'Write a complete blog post from scratch or based on a narrative',\n  parameters: {\n    narrativeId: {\n      type: 'string',\n      description: 'ID of the narrative to base the post on (optional)',\n      required: false,\n    },\n    title: {\n      type: 'string',\n      description: 'Title of the blog post (required if narrativeId not provided)',\n      required: false,\n    },\n    topic: {\n      type: 'string',\n      description: 'Topic of the blog post (required if narrativeId not provided)',\n      required: false,\n    },\n    keywords: {\n      type: 'array',\n      items: {\n        type: 'string',\n      },\n      description: 'Keywords for the blog post (optional)',\n      required: false,\n    },\n    wordCount: {\n      type: 'number',\n      description: 'Target word count for the post',\n      default: 1000,\n    },\n    style: {\n      type: 'string',\n      description: 'Writing style for the post',\n      enum: ['informative', 'persuasive', 'storytelling', 'technical', 'conversational'],\n      default: 'informative',\n    },\n  },\n  handler: async ({ narrativeId, title, topic, keywords, wordCount, style }, { claudeService }) => {\n    // Validate .postgen directory exists\n    const postgenDir = path.join(process.cwd(), '.postgen');\n    try {\n      await fs.access(postgenDir);\n    } catch (error) {\n      throw new Error('Please run the init prompt first');\n    }\n    \n    // Get domain from config\n    const config = await getPostgenConfig(postgenDir);\n    \n    // Get tone analysis for the domain\n    const toneAnalysis = await getExistingToneAnalysis(config.domain, postgenDir);\n    \n    let narrative = null;\n    \n    // If narrativeId is provided, get the narrative\n    if (narrativeId) {\n      narrative = await getNarrative(narrativeId, postgenDir);\n      title = narrative.title;\n      topic = narrative.post.topic;\n      keywords = narrative.post.keywords;\n    } else if (!title || !topic) {\n      throw new Error('Either narrativeId or both title and topic must be provided.');\n    }\n    \n    // Generate blog post with Claude\n    const prompt = buildBlogPostPrompt({\n      title,\n      topic,\n      keywords: keywords || [],\n      wordCount,\n      style,\n      toneAnalysis,\n      narrative: narrative ? narrative.rawNarrative : null,\n      domain: config.domain,\n    });\n    \n    const blogPost = await claudeService.generateContent(prompt);\n    \n    // Save the blog post\n    const postId = Date.now();\n    const postPath = path.join(postgenDir, 'posts', `${postId}.md`);\n    await fs.mkdir(path.dirname(postPath), { recursive: true });\n    \n    // Add metadata as frontmatter\n    const frontmatter = `---\ntitle: ${title}\ntopic: ${topic}\nkeywords: ${(keywords || []).join(', ')}\nwordCount: ${wordCount}\nstyle: ${style}\ncreatedAt: ${new Date().toISOString()}\nnarrativeId: ${narrativeId || null}\n---\\n\\n`;\n    \n    await fs.writeFile(postPath, frontmatter + blogPost);\n    \n    // Save metadata separately\n    const metaPath = path.join(postgenDir, 'posts', `${postId}.json`);\n    const metadata = {\n      id: postId.toString(),\n      title,\n      topic,\n      keywords: keywords || [],\n      wordCount,\n      style,\n      narrativeId: narrativeId || null,\n      createdAt: new Date().toISOString(),\n    };\n    \n    await fs.writeFile(metaPath, JSON.stringify(metadata, null, 2));\n    \n    return {\n      ...metadata,\n      excerpt: blogPost.substring(0, 200) + '...',\n      filePath: postPath,\n    };\n  },\n};\n\nfunction buildBlogPostPrompt(options) {\n  // Build a prompt for blog post generation based on options\n  let prompt = `Write a ${options.style} blog post about ${options.topic} with the title \"${options.title}\".`;\n  \n  if (options.keywords && options.keywords.length > 0) {\n    prompt += `\\n\\nInclude these keywords: ${options.keywords.join(', ')}`;\n  }\n  \n  prompt += `\\n\\nThe post should be approximately ${options.wordCount} words.`;\n  \n  if (options.toneAnalysis) {\n    prompt += `\\n\\nUse this tone of voice: ${options.toneAnalysis}`;\n  }\n  \n  if (options.narrative) {\n    prompt += `\\n\\nBase the post on this narrative outline:\\n${options.narrative}`;\n  }\n  \n  prompt += `\\n\\nThis is for the blog at ${options.domain}.`;\n  \n  return prompt;\n}\n\nasync function getPostgenConfig(postgenDir) {\n  // Get the postgen config\n  const configPath = path.join(postgenDir, 'config.json');\n  const configData = await fs.readFile(configPath, 'utf-8');\n  return JSON.parse(configData);\n}\n\nasync function getExistingToneAnalysis(domain, postgenDir) {\n  // Get existing tone analysis for the domain\n}\n\nasync function getNarrative(narrativeId, postgenDir) {\n  // Get a narrative by ID\n}\n```",
        "testStrategy": "Test post generation with and without narratives. Test different styles and word counts. Verify posts are correctly stored in the .postgen directory. Test error handling for missing narratives or invalid parameters.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Tool and Prompt Registration System",
        "description": "Implement a system to register and manage all tools and prompts in the MCP server.",
        "details": "1. Create a registry class to manage tools and prompts\n2. Implement registration methods for tools and prompts\n3. Add validation to ensure all tools and prompts meet the MCP specification\n4. Implement discovery mechanisms for clients to explore available tools and prompts\n5. Add versioning support for tools and prompts\n\n```typescript\nimport { MCPTool, MCPPrompt, MCPServer } from '@modelcontextprotocol/sdk';\n\nexport class ToolAndPromptRegistry {\n  private tools: Map<string, MCPTool> = new Map();\n  private prompts: Map<string, MCPPrompt> = new Map();\n  private server: MCPServer;\n  \n  constructor(server: MCPServer) {\n    this.server = server;\n  }\n  \n  registerTool(tool: MCPTool): void {\n    // Validate tool\n    this.validateTool(tool);\n    \n    // Register with the server\n    this.server.registerTool(tool);\n    \n    // Store in our registry\n    this.tools.set(tool.name, tool);\n    \n    console.log(`Registered tool: ${tool.name}`);\n  }\n  \n  registerPrompt(prompt: MCPPrompt): void {\n    // Validate prompt\n    this.validatePrompt(prompt);\n    \n    // Register with the server\n    this.server.registerPrompt(prompt);\n    \n    // Store in our registry\n    this.prompts.set(prompt.name, prompt);\n    \n    console.log(`Registered prompt: ${prompt.name}`);\n  }\n  \n  registerAll(tools: MCPTool[], prompts: MCPPrompt[]): void {\n    tools.forEach(tool => this.registerTool(tool));\n    prompts.forEach(prompt => this.registerPrompt(prompt));\n  }\n  \n  private validateTool(tool: MCPTool): void {\n    // Validate tool has required properties\n    if (!tool.name || !tool.description || !tool.handler) {\n      throw new Error(`Invalid tool: ${tool.name}. Missing required properties.`);\n    }\n    \n    // Validate tool name follows convention\n    if (!tool.name.startsWith('marketing_post_generator_mcp__')) {\n      throw new Error(`Invalid tool name: ${tool.name}. Must start with 'marketing_post_generator_mcp__'.`);\n    }\n  }\n  \n  private validatePrompt(prompt: MCPPrompt): void {\n    // Validate prompt has required properties\n    if (!prompt.name || !prompt.description || !prompt.handler) {\n      throw new Error(`Invalid prompt: ${prompt.name}. Missing required properties.`);\n    }\n    \n    // Validate prompt name follows convention\n    if (!prompt.name.startsWith('marketing_post_generator_mcp__')) {\n      throw new Error(`Invalid prompt name: ${prompt.name}. Must start with 'marketing_post_generator_mcp__'.`);\n    }\n  }\n  \n  getToolsInfo(): any[] {\n    return Array.from(this.tools.values()).map(tool => ({\n      name: tool.name,\n      description: tool.description,\n      parameters: tool.parameters,\n    }));\n  }\n  \n  getPromptsInfo(): any[] {\n    return Array.from(this.prompts.values()).map(prompt => ({\n      name: prompt.name,\n      description: prompt.description,\n      parameters: prompt.parameters,\n    }));\n  }\n}\n```",
        "testStrategy": "Test registration of tools and prompts. Test validation of tool and prompt properties. Test discovery mechanisms. Verify tools and prompts are correctly registered with the MCP server.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Docker Containerization",
        "description": "Implement Docker support for containerized deployment of the Marketing Post Generator MCP server.",
        "details": "1. Create a Dockerfile for the application\n2. Set up docker-compose.yml for local development\n3. Configure environment variables for container deployment\n4. Implement volume mounting for persistent .postgen data\n5. Add health checks and container lifecycle management\n6. Create scripts for building and deploying containers\n\n```dockerfile\n# Dockerfile\nFROM node:18-alpine\n\nWORKDIR /app\n\n# Install dependencies\nCOPY package*.json ./\nRUN npm ci --only=production\n\n# Copy application code\nCOPY dist/ ./dist/\n\n# Create directory for .postgen data\nRUN mkdir -p /data/.postgen\n\n# Set environment variables\nENV NODE_ENV=production\nENV MCP_MODE=remote\nENV MCP_PORT=3000\nENV POSTGEN_DATA_DIR=/data/.postgen\n\n# Expose the port\nEXPOSE 3000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1\n\n# Start the application\nCMD [\"node\", \"dist/index.js\"]\n```\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  marketing-post-generator:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n      - MCP_MODE=remote\n      - MCP_PORT=3000\n      - CLAUDE_API_KEY=${CLAUDE_API_KEY}\n      - POSTGEN_DATA_DIR=/data/.postgen\n    volumes:\n      - postgen-data:/data/.postgen\n    healthcheck:\n      test: [\"CMD\", \"wget\", \"--no-verbose\", \"--tries=1\", \"--spider\", \"http://localhost:3000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 5s\n\nvolumes:\n  postgen-data:\n```\n\n```typescript\n// src/config.ts\nexport const config = {\n  server: {\n    mode: process.env.MCP_MODE || 'local',\n    port: parseInt(process.env.MCP_PORT || '3000', 10),\n  },\n  claude: {\n    apiKey: process.env.CLAUDE_API_KEY,\n  },\n  postgen: {\n    dataDir: process.env.POSTGEN_DATA_DIR || '.postgen',\n  },\n};\n```\n\n```bash\n#!/bin/bash\n# scripts/build-docker.sh\nset -e\n\n# Build TypeScript\nnpm run build\n\n# Build Docker image\ndocker build -t marketing-post-generator .\n\necho \"Docker image built successfully!\"\n```",
        "testStrategy": "Test Docker build process. Verify container starts correctly. Test volume mounting for persistent data. Verify environment variable configuration works. Test health check endpoint.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Error Handling and Logging System",
        "description": "Implement a comprehensive error handling and logging system for the MCP server.",
        "details": "1. Create a logging service with different log levels\n2. Implement structured error handling for all tools and prompts\n3. Add request/response logging for remote mode\n4. Implement error reporting and monitoring\n5. Add rate limiting and throttling for error conditions\n\n```typescript\nimport * as winston from 'winston';\n\n// Log levels: error, warn, info, http, verbose, debug, silly\nexport const logger = winston.createLogger({\n  level: process.env.LOG_LEVEL || 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  defaultMeta: { service: 'marketing-post-generator' },\n  transports: [\n    new winston.transports.Console({\n      format: winston.format.combine(\n        winston.format.colorize(),\n        winston.format.simple()\n      ),\n    }),\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'combined.log' }),\n  ],\n});\n\nexport class ErrorHandler {\n  static async wrapHandler(handler: Function, context: any) {\n    try {\n      return await handler(context);\n    } catch (error) {\n      logger.error('Error in handler', {\n        error: error.message,\n        stack: error.stack,\n        context,\n      });\n      \n      // Determine if this is a user error or system error\n      if (error.name === 'ValidationError' || error.name === 'UserInputError') {\n        throw new Error(`Invalid input: ${error.message}`);\n      }\n      \n      // For system errors, provide a generic message\n      throw new Error('An internal error occurred. Please try again later.');\n    }\n  }\n  \n  static createMiddleware() {\n    return async (req, res, next) => {\n      const start = Date.now();\n      \n      // Add request ID\n      req.id = crypto.randomUUID();\n      \n      // Log request\n      logger.http('Incoming request', {\n        id: req.id,\n        method: req.method,\n        path: req.path,\n        ip: req.ip,\n      });\n      \n      // Capture response\n      const originalSend = res.send;\n      res.send = function(body) {\n        const duration = Date.now() - start;\n        \n        logger.http('Outgoing response', {\n          id: req.id,\n          statusCode: res.statusCode,\n          duration,\n        });\n        \n        return originalSend.call(this, body);\n      };\n      \n      try {\n        await next();\n      } catch (error) {\n        logger.error('Error in request', {\n          id: req.id,\n          error: error.message,\n          stack: error.stack,\n        });\n        \n        res.status(500).json({\n          error: 'An internal error occurred',\n          requestId: req.id,\n        });\n      }\n    };\n  }\n}\n\n// Rate limiter\nexport class RateLimiter {\n  private limits: Map<string, { count: number, resetAt: number }> = new Map();\n  private readonly maxRequests: number;\n  private readonly windowMs: number;\n  \n  constructor(maxRequests = 100, windowMs = 60000) {\n    this.maxRequests = maxRequests;\n    this.windowMs = windowMs;\n  }\n  \n  check(key: string): boolean {\n    const now = Date.now();\n    \n    // Get or create limit entry\n    let limit = this.limits.get(key);\n    if (!limit || now > limit.resetAt) {\n      limit = { count: 0, resetAt: now + this.windowMs };\n      this.limits.set(key, limit);\n    }\n    \n    // Check if limit exceeded\n    if (limit.count >= this.maxRequests) {\n      return false;\n    }\n    \n    // Increment count\n    limit.count++;\n    return true;\n  }\n  \n  getRemainingRequests(key: string): number {\n    const now = Date.now();\n    const limit = this.limits.get(key);\n    \n    if (!limit || now > limit.resetAt) {\n      return this.maxRequests;\n    }\n    \n    return Math.max(0, this.maxRequests - limit.count);\n  }\n  \n  getResetTime(key: string): number {\n    const limit = this.limits.get(key);\n    return limit ? limit.resetAt : Date.now() + this.windowMs;\n  }\n}\n```",
        "testStrategy": "Test logging at different levels. Test error handling for various error types. Test rate limiting functionality. Verify request/response logging in remote mode. Test error reporting and monitoring.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Testing Framework Setup",
        "description": "Set up a comprehensive testing framework for the MCP server, including unit tests, integration tests, and end-to-end tests.",
        "details": "1. Set up Jest for unit testing\n2. Implement test utilities for mocking Claude Code and MCP Server\n3. Create integration tests for each tool and prompt\n4. Set up end-to-end tests for the complete workflow\n5. Implement test coverage reporting\n\n```typescript\n// jest.config.js\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/src'],\n  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  collectCoverage: true,\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n    '!src/**/__tests__/**',\n  ],\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov'],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80,\n    },\n  },\n};\n```\n\n```typescript\n// src/__tests__/utils/mocks.ts\nimport { MCPServer, MCPTool, MCPPrompt } from '@modelcontextprotocol/sdk';\n\n// Mock Claude Service\nexport class MockClaudeService {\n  async generateContent(prompt: string) {\n    // Return mock content based on the prompt\n    if (prompt.includes('summarize')) {\n      return 'This is a mock summary of the content.';\n    }\n    if (prompt.includes('tone')) {\n      return 'The tone is professional and informative.';\n    }\n    if (prompt.includes('content plan')) {\n      return 'Content plan with 4 post ideas: [...]';\n    }\n    if (prompt.includes('blog post')) {\n      return '# Mock Blog Post\\n\\nThis is a mock blog post generated for testing.';\n    }\n    \n    return 'Mock content generated for testing.';\n  }\n}\n\n// Mock MCP Server\nexport class MockMCPServer {\n  private tools: Map<string, MCPTool> = new Map();\n  private prompts: Map<string, MCPPrompt> = new Map();\n  \n  registerTool(tool: MCPTool) {\n    this.tools.set(tool.name, tool);\n  }\n  \n  registerPrompt(prompt: MCPPrompt) {\n    this.prompts.set(prompt.name, tool);\n  }\n  \n  async start() {\n    // Mock start\n  }\n  \n  async stop() {\n    // Mock stop\n  }\n  \n  getRegisteredTools() {\n    return Array.from(this.tools.values());\n  }\n  \n  getRegisteredPrompts() {\n    return Array.from(this.prompts.values());\n  }\n}\n\n// Mock file system\nexport const mockFs = {\n  promises: {\n    mkdir: jest.fn().mockResolvedValue(undefined),\n    writeFile: jest.fn().mockResolvedValue(undefined),\n    readFile: jest.fn().mockImplementation((path) => {\n      if (path.includes('config.json')) {\n        return Promise.resolve(JSON.stringify({\n          domain: 'example.com',\n          initialized: '2023-01-01T00:00:00.000Z',\n        }));\n      }\n      if (path.includes('content-plans')) {\n        return Promise.resolve(JSON.stringify({\n          domain: 'example.com',\n          timeframe: 'month',\n          postCount: 4,\n          plan: [\n            { id: '1', title: 'Test Post 1', topic: 'Testing' },\n            { id: '2', title: 'Test Post 2', topic: 'Mocking' },\n          ],\n        }));\n      }\n      \n      throw new Error(`File not found: ${path}`);\n    }),\n    access: jest.fn().mockResolvedValue(undefined),\n  },\n};\n```\n\n```typescript\n// src/__tests__/tools/sample.test.ts\nimport { sampleTool } from '../../tools/sample';\nimport { MockClaudeService, mockFs } from '../utils/mocks';\n\n// Mock dependencies\njest.mock('fs/promises', () => mockFs.promises);\n\ndescribe('Sample Tool', () => {\n  const mockClaudeService = new MockClaudeService();\n  \n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  it('should sample blog posts from a domain', async () => {\n    const result = await sampleTool.handler(\n      { domain: 'example.com', sampleSize: 3 },\n      { claudeService: mockClaudeService }\n    );\n    \n    expect(result).toHaveProperty('message');\n    expect(result).toHaveProperty('analysis');\n    expect(mockFs.promises.writeFile).toHaveBeenCalled();\n  });\n  \n  it('should throw an error if .postgen directory does not exist', async () => {\n    mockFs.promises.access.mockRejectedValueOnce(new Error('Directory not found'));\n    \n    await expect(sampleTool.handler(\n      { domain: 'example.com', sampleSize: 3 },\n      { claudeService: mockClaudeService }\n    )).rejects.toThrow('Please run the init prompt first');\n  });\n});\n```\n\n```typescript\n// src/__tests__/integration/workflow.test.ts\nimport { MarketingPostGeneratorServer } from '../../server';\nimport { initPrompt } from '../../prompts/init';\nimport { sampleTool } from '../../tools/sample';\nimport { summarizeTool } from '../../tools/summarize';\nimport { contentPlanTool } from '../../tools/content-plan';\nimport { blogPostGeneratorTool } from '../../tools/write-post';\n\n// This test requires actual file system access and Claude API key\n// Skip in CI unless environment is properly configured\nconst runIntegrationTests = process.env.RUN_INTEGRATION_TESTS === 'true';\n\n(runIntegrationTests ? describe : describe.skip)('End-to-end workflow', () => {\n  let server;\n  \n  beforeAll(async () => {\n    server = new MarketingPostGeneratorServer({\n      mode: 'local',\n      claudeApiKey: process.env.CLAUDE_API_KEY,\n    });\n    \n    await server.start();\n  });\n  \n  afterAll(async () => {\n    await server.stop();\n  });\n  \n  it('should complete a full workflow', async () => {\n    // Step 1: Initialize with a domain\n    const initResult = await server.executePrompt('marketing_post_generator_mcp__init', {\n      domain: 'https://example.com',\n    });\n    expect(initResult).toContain('Successfully initialized');\n    \n    // Step 2: Sample the domain\n    const sampleResult = await server.executeTool('marketing_post_generator_mcp__sample', {\n      domain: 'example.com',\n      sampleSize: 2,\n    });\n    expect(sampleResult).toHaveProperty('analysis');\n    \n    // Step 3: Create a content plan\n    const planResult = await server.executeTool('marketing_post_generator_mcp__content_plan', {\n      domain: 'example.com',\n      timeframe: 'week',\n      postCount: 2,\n    });\n    expect(planResult).toHaveProperty('plan');\n    \n    // Step 4: Write a blog post\n    const postResult = await server.executeTool('marketing_post_generator_mcp__write_post', {\n      title: 'Test Post',\n      topic: 'Integration Testing',\n      wordCount: 500,\n    });\n    expect(postResult).toHaveProperty('filePath');\n  }, 30000); // Increase timeout for this test\n});\n```",
        "testStrategy": "Run unit tests for individual components. Run integration tests for tool and prompt combinations. Run end-to-end tests for complete workflows. Verify test coverage meets thresholds.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Documentation and Examples",
        "description": "Create comprehensive documentation and examples for using the Marketing Post Generator MCP server.",
        "details": "1. Create a README.md with installation and usage instructions\n2. Document all tools and prompts with examples\n3. Create example scripts for common workflows\n4. Add API documentation for programmatic usage\n5. Create a user guide for content writers\n\n```markdown\n# Marketing Post Generator MCP\n\nAn MCP server that leverages AI to automate the creation of marketing blog posts.\n\n## Features\n\n- Sample blog posts from a domain to extract positioning, tone, and content strategy\n- Summarize individual blog posts\n- Create and manage content plans for future posts\n- Generate narratives and bullet points for upcoming posts\n- Write complete blog posts from scratch\n\n## Installation\n\n### Prerequisites\n\n- Node.js 18 or higher\n- npm or yarn\n- Claude API key\n\n### Install from npm\n\n```bash\nnpm install marketing-post-generator-mcp\n```\n\n### Or clone and build from source\n\n```bash\ngit clone https://github.com/yourusername/marketing-post-generator-mcp.git\ncd marketing-post-generator-mcp\nnpm install\nnpm run build\n```\n\n## Usage\n\n### Environment Variables\n\nCreate a `.env` file with the following variables:\n\n```\nCLAUDE_API_KEY=your_api_key_here\nMCP_MODE=local  # or 'remote'\nMCP_PORT=3000   # for remote mode\n```\n\n### Start the server\n\n```bash\nnpm start\n```\n\n### Using Docker\n\n```bash\ndocker-compose up -d\n```\n\n## MCP Tools and Prompts\n\n### Initialization\n\nBefore using any tools, initialize the generator with a blog domain:\n\n```\n/marketing_post_generator_mcp__init https://example.com/blog\n```\n\n### Sample Blog Posts\n\nSample and analyze blog posts from a domain:\n\n```\n/marketing_post_generator_mcp__sample example.com 5\n```\n\n### Summarize a Blog Post\n\nGenerate a summary of a specific blog post:\n\n```\n/marketing_post_generator_mcp__summarize https://example.com/blog/post-1\n```\n\n### Create a Content Plan\n\nGenerate a content plan for future posts:\n\n```\n/marketing_post_generator_mcp__content_plan example.com month 4\n```\n\n### Generate a Post Narrative\n\nCreate a narrative outline for a post from the content plan:\n\n```\n/marketing_post_generator_mcp__generate_narrative post-id-1 detailed\n```\n\n### Write a Blog Post\n\nGenerate a complete blog post:\n\n```\n/marketing_post_generator_mcp__write_post --title=\"My Blog Post\" --topic=\"AI Content Generation\" --wordCount=1000\n```\n\nOr based on a narrative:\n\n```\n/marketing_post_generator_mcp__write_post --narrativeId=narrative-id-1 --wordCount=1500\n```\n\n## Example Workflows\n\n### Complete Content Generation Pipeline\n\n1. Initialize with your blog domain\n2. Sample existing content to understand tone and style\n3. Generate a content plan for the next month\n4. Create narratives for each post in the plan\n5. Generate complete blog posts from the narratives\n\n## API Documentation\n\nFor programmatic usage, see the [API Documentation](docs/api.md).\n\n## License\n\nMIT\n```\n\n```typescript\n// examples/complete-workflow.ts\nimport { MarketingPostGeneratorClient } from '../src/client';\n\nasync function runWorkflow() {\n  // Create client\n  const client = new MarketingPostGeneratorClient({\n    mode: 'local',\n    claudeApiKey: process.env.CLAUDE_API_KEY,\n  });\n  \n  try {\n    // Initialize with a domain\n    await client.init('https://example.com/blog');\n    console.log('Initialized with domain');\n    \n    // Sample the domain\n    const sampleResult = await client.sample('example.com', 5);\n    console.log('Sample analysis:', sampleResult.analysis);\n    \n    // Create a content plan\n    const planResult = await client.createContentPlan('example.com', 'month', 4);\n    console.log('Content plan created with', planResult.plan.length, 'posts');\n    \n    // Generate a post from the first item in the plan\n    const firstPost = planResult.plan[0];\n    const postResult = await client.writePost({\n      title: firstPost.title,\n      topic: firstPost.topic,\n      keywords: firstPost.keywords,\n      wordCount: 1000,\n    });\n    \n    console.log('Generated post saved to:', postResult.filePath);\n  } catch (error) {\n    console.error('Workflow error:', error);\n  } finally {\n    await client.close();\n  }\n}\n\nrunWorkflow().catch(console.error);\n```",
        "testStrategy": "Verify documentation accuracy by following the instructions. Test example scripts to ensure they work as documented. Review API documentation for completeness and accuracy.",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-04T10:32:12.253Z",
      "updated": "2025-07-04T14:33:27.627Z",
      "description": "Tasks for master context"
    }
  }
}