import { jest } from '@jest/globals';
import { IClaudeService } from '../../services/claude/index.js';
import { SearchService } from '../../services/search/index.js';
import type { Tool, Prompt } from '@modelcontextprotocol/sdk/types.js';

// Mock Claude Service
export class MockClaudeService implements IClaudeService {
  async generateContent(prompt: string): Promise<string> {
    // Return mock content based on the prompt
    if (prompt.includes('summarize')) {
      return 'This is a mock summary of the content. The main points covered include testing, mocking, and implementation strategies.';
    }
    if (prompt.includes('tone')) {
      return JSON.stringify({
        tone: 'professional and informative',
        characteristics: ['clear', 'technical', 'helpful'],
        examples: ['Well-structured explanations', 'Use of examples'],
      });
    }
    if (prompt.includes('content plan')) {
      return JSON.stringify({
        timeframe: 'month',
        posts: [
          { id: '1', title: 'Getting Started with Testing', topic: 'Testing Basics' },
          { id: '2', title: 'Advanced Mocking Strategies', topic: 'Unit Testing' },
          { id: '3', title: 'Integration Testing Best Practices', topic: 'Integration' },
          { id: '4', title: 'End-to-End Testing Guide', topic: 'E2E Testing' },
        ],
      });
    }
    if (prompt.includes('narrative') || prompt.includes('bullet points')) {
      return JSON.stringify({
        narrative: 'This post will explore testing strategies for modern applications.',
        bulletPoints: [
          'Understanding different types of tests',
          'Setting up Jest and testing utilities',
          'Creating effective mocks and stubs',
          'Best practices for maintainable tests',
        ],
      });
    }
    if (prompt.includes('blog post')) {
      return `# Mock Blog Post

## Introduction
This is a mock blog post generated for testing purposes.

## Main Content
The content covers important topics related to software testing and development.

## Conclusion
Testing is essential for building reliable software applications.

---
*Generated by Mock Claude Service for testing*`;
    }

    return 'Mock content generated for testing purposes.';
  }

  // Additional methods that might be needed
  async generateStructuredContent(prompt: string, schema?: any): Promise<any> {
    const content = await this.generateContent(prompt);
    try {
      return JSON.parse(content);
    } catch {
      return { content };
    }
  }
}

// Mock Search Service
export class MockSearchService implements SearchService {
  async search(query: string, options?: any): Promise<any> {
    return {
      results: [
        {
          title: 'Mock Search Result 1',
          url: 'https://example.com/post1',
          content: 'This is mock content from the first search result.',
          excerpt: 'Mock excerpt for testing purposes...',
        },
        {
          title: 'Mock Search Result 2',
          url: 'https://example.com/post2',
          content: 'This is mock content from the second search result.',
          excerpt: 'Another mock excerpt for comprehensive testing...',
        },
      ],
      totalResults: 2,
      query,
    };
  }

  async searchDomain(domain: string, options?: any): Promise<any> {
    return {
      domain,
      posts: [
        {
          title: 'Sample Blog Post 1',
          url: `https://${domain}/post1`,
          content: 'Sample content for blog post 1',
          publishedDate: '2023-01-01',
        },
        {
          title: 'Sample Blog Post 2',
          url: `https://${domain}/post2`,
          content: 'Sample content for blog post 2',
          publishedDate: '2023-01-02',
        },
      ],
      analysis: {
        totalPosts: 2,
        averageLength: 500,
        commonTopics: ['technology', 'testing'],
        tone: 'professional',
      },
    };
  }

  async getContent(url: string): Promise<any> {
    return {
      url,
      title: 'Mock Page Title',
      content: 'This is mock page content for testing.',
      metadata: {
        author: 'Mock Author',
        publishedDate: '2023-01-01',
        tags: ['testing', 'mock'],
      },
    };
  }
}

// Mock file system utilities
export const mockFs = {
  promises: {
    mkdir: jest.fn().mockResolvedValue(undefined),
    writeFile: jest.fn().mockResolvedValue(undefined),
    readFile: jest.fn().mockImplementation((path: string) => {
      if (path.includes('config.json')) {
        return Promise.resolve(
          JSON.stringify({
            domain: 'example.com',
            initialized: '2023-01-01T00:00:00.000Z',
          })
        );
      }
      if (path.includes('content-plans')) {
        return Promise.resolve(
          JSON.stringify({
            domain: 'example.com',
            timeframe: 'month',
            postCount: 4,
            plan: [
              { id: '1', title: 'Test Post 1', topic: 'Testing' },
              { id: '2', title: 'Test Post 2', topic: 'Mocking' },
            ],
          })
        );
      }
      if (path.includes('tone-analysis')) {
        return Promise.resolve(
          JSON.stringify({
            domain: 'example.com',
            tone: 'professional',
            characteristics: ['clear', 'technical'],
            confidence: 0.85,
          })
        );
      }
      if (path.includes('narratives')) {
        return Promise.resolve(
          JSON.stringify({
            postId: 'test-post-1',
            narrative: 'Test narrative for mock post',
            bulletPoints: ['Point 1', 'Point 2', 'Point 3'],
          })
        );
      }

      throw new Error(`Mock file not found: ${path}`);
    }),
    access: jest.fn().mockResolvedValue(undefined),
    stat: jest.fn().mockResolvedValue({
      isDirectory: () => true,
      isFile: () => true,
      size: 1024,
      mtime: new Date('2023-01-01'),
    }),
  },
};

// Mock registry entries for testing
export const mockRegistryEntries = {
  tool: {
    toolDefinition: {
      name: 'test_tool',
      description: 'A test tool for mocking',
      inputSchema: {
        type: 'object',
        properties: {
          input: { type: 'string' },
        },
      },
    } as Tool,
    handler: jest.fn().mockResolvedValue('Mock tool result'),
    metadata: {
      version: { major: 1, minor: 0, patch: 0 },
      author: 'Test Suite',
      tags: ['test', 'mock'],
      createdAt: new Date('2023-01-01'),
      updatedAt: new Date('2023-01-01'),
    },
  },
  prompt: {
    promptDefinition: {
      name: 'test_prompt',
      description: 'A test prompt for mocking',
      arguments: [
        {
          name: 'input',
          description: 'Test input',
          required: true,
        },
      ],
    } as Prompt,
    handler: jest.fn().mockResolvedValue('Mock prompt result'),
    metadata: {
      version: { major: 1, minor: 0, patch: 0 },
      author: 'Test Suite',
      tags: ['test', 'mock'],
      createdAt: new Date('2023-01-01'),
      updatedAt: new Date('2023-01-01'),
    },
  },
};

// Utility functions for creating test data
export const createMockToolDefinition = (name: string): Tool => ({
  name,
  description: `Mock tool: ${name}`,
  inputSchema: {
    type: 'object',
    properties: {
      input: { type: 'string', description: 'Test input' },
    },
    required: ['input'],
  },
});

export const createMockPromptDefinition = (name: string): Prompt => ({
  name,
  description: `Mock prompt: ${name}`,
  arguments: [
    {
      name: 'input',
      description: 'Test input parameter',
      required: true,
    },
  ],
});
